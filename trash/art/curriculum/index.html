<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Procedural Curriculum Maker — Interactive Lessons</title>
    <style>
      :root { --bg:#0b0c10; --fg:#c5c6c7; --accent:#66fcf1; --muted:#9ea6ae; }
      html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial, sans-serif; }
      header { padding:12px 16px; border-bottom:1px solid #1f2833; display:flex; align-items:center; gap:12px; }
      header h1 { margin:0; font-size:18px; color:var(--accent); }
      main { display:grid; grid-template-columns: 320px 1fr; gap:12px; height: calc(100% - 56px); }
      @media (max-width: 900px) { main { grid-template-columns: 1fr; grid-template-rows: auto 1fr; } }
      .panel { padding:12px; overflow:auto; }
      .controls { display:grid; gap:10px; }
      .row { display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
      label { font-size:12px; color:var(--muted); width: 120px; }
      select, input, button, textarea { background:#111318; color:var(--fg); border:1px solid #2b3440; border-radius:6px; padding:6px 8px; }
      input[type=range]{ width: 180px; }
      button { cursor:pointer; }
      button.primary{ background:#13343b; border-color:#1b5864; color:#bdf9f5; }
      .preview { position:relative; background:#000; height:100%; display:grid; grid-template-rows: auto 1fr; }
      .tabs { display:flex; gap:8px; padding:8px; border-bottom:1px solid #1f2833; }
      .tab { padding:6px 10px; border:1px solid #2b3440; border-bottom:none; border-radius:6px 6px 0 0; background:#0e1116; cursor:pointer; }
      .tab.active { background:#13343b; color:#bdf9f5; border-color:#1b5864; }
      .lesson { display:none; height:100%; }
      .lesson.active { display:grid; grid-template-rows: auto 1fr; }
      .lesson header { padding:8px 12px; border: none; }
      .canvasWrap { display:grid; place-items:center; padding:8px; }
      canvas { background:#0a0a0a; border:1px solid #222; border-radius:6px; max-width:100%; height:auto; }
      .small { font-size:12px; color:var(--muted); }
      .footer { font-size:12px; color:#8a8f98; padding-top:8px; border-top:1px dashed #23303b; }
      textarea { width:100%; min-height: 64px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    </style>
  </head>
  <body>
    <header>
      <h1>Procedural Curriculum Maker</h1>
      <span class="small">Interactive lessons to teach algorithms and generative art</span>
    </header>
    <main>
      <section class="panel">
        <div class="controls">
          <div class="row"><strong>Pick a lesson</strong></div>
          <div class="row">
            <button class="tab active" data-tab="sorting">Sorting Visualizer</button>
            <button class="tab" data-tab="lsys">L-System Fractals</button>
          </div>
          <div class="footer">
            Tip: Each lesson has inline controls and a short explainer.
          </div>
        </div>
      </section>
      <section class="preview">
        <div class="lesson active" id="lesson-sorting">
          <header>
            <div class="small">Goal: See how different sorting algorithms operate step-by-step. Adjust array size and animation speed, pause, and step manually.</div>
          </header>
          <div class="canvasWrap">
            <canvas id="sortCanvas" width="960" height="480"></canvas>
          </div>
          <div class="panel">
            <div class="controls">
              <div class="row">
                <label for="alg">Algorithm</label>
                <select id="alg">
                  <option value="bubble">Bubble sort</option>
                  <option value="insertion">Insertion sort</option>
                  <option value="selection">Selection sort</option>
                  <option value="quick">Quick sort</option>
                </select>
              </div>
              <div class="row">
                <label for="n">Array size</label>
                <input type="range" id="n" min="8" max="200" value="64" />
                <span id="nVal" class="small">64</span>
              </div>
              <div class="row">
                <label for="speed">Speed (ms/step)</label>
                <input type="range" id="speed" min="0" max="200" value="10" />
                <span id="speedVal" class="small">10</span>
              </div>
              <div class="row">
                <button id="shuffle">Shuffle</button>
                <button id="start" class="primary">Start</button>
                <button id="pause">Pause</button>
                <button id="step">Step</button>
              </div>
              <div class="small">Explanation: Bubble repeatedly swaps adjacent out-of-order pairs. Insertion grows a sorted prefix by inserting next elements. Selection picks the smallest remaining each pass. Quick uses divide-and-conquer around a pivot.</div>
            </div>
          </div>
        </div>

        <div class="lesson" id="lesson-lsys">
          <header>
            <div class="small">Goal: Explore L-systems (string rewriting) to generate fractals and plants. Choose a preset, tweak rules, and iterate count.</div>
          </header>
          <div class="canvasWrap">
            <canvas id="lsCanvas" width="960" height="600"></canvas>
          </div>
          <div class="panel">
            <div class="controls">
              <div class="row">
                <label for="preset">Preset</label>
                <select id="preset">
                  <option value="koch">Koch Curve</option>
                  <option value="tree">Stochastic Tree</option>
                  <option value="dragon">Dragon Curve</option>
                </select>
              </div>
              <div class="row">
                <label for="axiom">Axiom</label>
                <input type="text" id="axiom" value="F" />
              </div>
              <div class="row" style="align-items:flex-start;">
                <label for="rules">Rules (JSON)</label>
                <textarea id="rules">{"F":"F+F−F−F+F"}</textarea>
              </div>
              <div class="row">
                <label for="angle">Angle (deg)</label>
                <input type="number" id="angle" value="90" />
              </div>
              <div class="row">
                <label for="iters">Iterations</label>
                <input type="range" id="iters" min="0" max="8" value="3" />
                <span id="itersVal" class="small">3</span>
              </div>
              <div class="row">
                <label for="len">Step length</label>
                <input type="range" id="len" min="1" max="20" value="6" />
                <span id="lenVal" class="small">6</span>
              </div>
              <div class="row">
                <button id="render" class="primary">Render</button>
                <button id="save">Save PNG</button>
              </div>
              <div class="small">Symbols: F move+draw, f move, + turn right, − turn left, [ push, ] pop. Dragon uses X/Y with rules not drawn, only F draws.</div>
            </div>
          </div>
        </div>
      </section>
    </main>
    <script>
      // Tabs
      const tabs = document.querySelectorAll('.tab');
      function setTab(name){
        tabs.forEach(t=>t.classList.toggle('active', t.dataset.tab===name));
        document.getElementById('lesson-sorting').classList.toggle('active', name==='sorting');
        document.getElementById('lesson-lsys').classList.toggle('active', name==='lsys');
      }
      tabs.forEach(t=>t.addEventListener('click', ()=>setTab(t.dataset.tab)));

      // Sorting visualizer
      const sCanvas = document.getElementById('sortCanvas');
      const sCtx = sCanvas.getContext('2d');
      const sState = { arr: [], i:0, j:0, n:64, running:false, timer:null, algo:'bubble', speed:10, stack:[], highlights:[], swaps:0, comps:0 };
      function genArray(){ sState.arr = Array.from({length:sState.n}, (_,i)=>i+1); for(let k=sState.arr.length-1;k>0;k--){ const r=Math.floor(Math.random()*(k+1)); [sState.arr[k],sState.arr[r]]=[sState.arr[r],sState.arr[k]]; } sState.i=0;sState.j=0;sState.stack=[]; sState.swaps=0; sState.comps=0; drawArray(); }
      function drawArray(){
        const W=sCanvas.width, H=sCanvas.height; sCtx.clearRect(0,0,W,H);
        const w=W/sState.arr.length;
        const max=Math.max(...sState.arr);
        for(let idx=0; idx<sState.arr.length; idx++){
          const v=sState.arr[idx];
          const h=(v/max)*(H-20);
          const x=idx*w; const y=H-h;
          let color = '#66fcf1';
          if (idx===sState.j || idx===sState.j+1) color = '#ffd166';
          if (sState.highlights.includes(idx)) color = '#ef476f';
          sCtx.fillStyle=color; sCtx.fillRect(x+1, y, w-2, h);
        }
        sCtx.fillStyle='#9ea6ae'; sCtx.fillText(`swaps:${sState.swaps} comps:${sState.comps}`, 8, 16);
      }
      function stepBubble(){
        if (sState.i >= sState.arr.length-1) return true;
        if (sState.j >= sState.arr.length-1 - sState.i){ sState.j=0; sState.i++; return false; }
        sState.comps++;
        if (sState.arr[sState.j] > sState.arr[sState.j+1]){ [sState.arr[sState.j], sState.arr[sState.j+1]]=[sState.arr[sState.j+1], sState.arr[sState.j]]; sState.swaps++; }
        sState.j++; return false;
      }
      function stepInsertion(){
        if (!sState.stack.length){ sState.i=1; sState.stack.push({phase:'outer'}); }
        const a=sState.arr;
        if (sState.i >= a.length) return true;
        if (sState.stack.at(-1).phase==='outer'){ sState.key=a[sState.i]; sState.j=sState.i-1; sState.stack.push({phase:'inner'}); }
        if (sState.stack.at(-1).phase==='inner'){
          if (sState.j>=0 && a[sState.j]>sState.key){ sState.comps++; a[sState.j+1]=a[sState.j]; sState.swaps++; sState.j--; }
          else { if (sState.j>=0) sState.comps++; a[sState.j+1]=sState.key; sState.i++; sState.stack.pop(); sState.stack.pop(); sState.stack.push({phase:'outer'}); }
        }
        return false;
      }
      function stepSelection(){
        const a=sState.arr; const n=a.length;
        if (!sState.stack.length){ sState.i=0; sState.stack.push({phase:'outer'}); }
        if (sState.i>=n-1) return true;
        if (sState.stack.at(-1).phase==='outer'){ sState.minIdx=sState.i; sState.j=sState.i+1; sState.stack.push({phase:'inner'}); }
        if (sState.stack.at(-1).phase==='inner'){
          if (sState.j<n){ sState.comps++; if (a[sState.j]<a[sState.minIdx]) sState.minIdx=sState.j; sState.j++; }
          else { if (sState.minIdx!==sState.i){ [a[sState.i],a[sState.minIdx]]=[a[sState.minIdx],a[sState.i]]; sState.swaps++; } sState.i++; sState.stack.pop(); sState.stack.pop(); sState.stack.push({phase:'outer'}); }
        }
        return false;
      }
      function stepQuick(){
        const a=sState.arr;
        if (!sState.stack.length) sState.stack.push({l:0, r:a.length-1, state:'partition'});
        if (!sState.stack.length) return true;
        const frame = sState.stack.at(-1);
        if (frame.state==='partition'){
          const {l,r} = frame; if (l>=r){ sState.stack.pop(); return false; }
          if (frame.i===undefined){ frame.i=l; frame.j=r-1; frame.p=a[r]; }
          while (frame.i<=frame.j && a[frame.i]<frame.p){ sState.comps++; frame.i++; }
          while (frame.j>=frame.i && a[frame.j]>frame.p){ sState.comps++; frame.j--; }
          if (frame.i<=frame.j){ [a[frame.i],a[frame.j]]=[a[frame.j],a[frame.i]]; sState.swaps++; frame.i++; frame.j--; }
          else { [a[frame.i],a[r]]=[a[r],a[frame.i]]; sState.swaps++; const pivot=frame.i; sState.stack.pop(); sState.stack.push({l:l, r:pivot-1, state:'partition'}); sState.stack.push({l:pivot+1, r:r, state:'partition'}); }
          return false;
        }
        return false;
      }
      const steppers = { bubble: stepBubble, insertion: stepInsertion, selection: stepSelection, quick: stepQuick };
      function tick(){ const done = steppers[sState.algo](); drawArray(); if (done){ stopRun(); } }
      function startRun(){ if (sState.running) return; sState.running=true; loop(); }
      function stopRun(){ sState.running=false; if (sState.timer){ clearTimeout(sState.timer); sState.timer=null; } }
      function loop(){ if (!sState.running) return; tick(); const delay = +document.getElementById('speed').value; sState.timer=setTimeout(loop, delay); }
      // UI bindings
      document.getElementById('alg').addEventListener('change', e=>{ sState.algo=e.target.value; sState.stack=[]; });
      document.getElementById('n').addEventListener('input', e=>{ sState.n=+e.target.value; document.getElementById('nVal').textContent=sState.n; genArray(); });
      document.getElementById('speed').addEventListener('input', e=>{ sState.speed=+e.target.value; document.getElementById('speedVal').textContent=sState.speed; });
      document.getElementById('shuffle').addEventListener('click', genArray);
      document.getElementById('start').addEventListener('click', startRun);
      document.getElementById('pause').addEventListener('click', stopRun);
      document.getElementById('step').addEventListener('click', ()=>{ stopRun(); tick(); });
      genArray();

      // L-system lesson
      const lCanvas = document.getElementById('lsCanvas');
      const lCtx = lCanvas.getContext('2d');
      function presets(name){
        if (name==='koch') return { axiom: 'F', rules: { 'F':'F+F−F−F+F' }, angle:90, iters:3, len:6 };
        if (name==='tree') return { axiom: 'F', rules: { 'F':'F[+F]F[-F]F' }, angle:25, iters:4, len:8 };
        if (name==='dragon') return { axiom: 'FX', rules: { 'X':'X+YF+', 'Y':'-FX-Y' }, angle:90, iters:10, len:7 };
        return { axiom:'F', rules:{'F':'F+F−F−F+F'}, angle:90, iters:3, len:6 };
      }
      function setPreset(name){ const p = presets(name); document.getElementById('axiom').value=p.axiom; document.getElementById('rules').value=JSON.stringify(p.rules); document.getElementById('angle').value=p.angle; document.getElementById('iters').value=p.iters; document.getElementById('itersVal').textContent=p.iters; document.getElementById('len').value=p.len; document.getElementById('lenVal').textContent=p.len; }
      document.getElementById('preset').addEventListener('change', e=>setPreset(e.target.value));
      document.getElementById('iters').addEventListener('input', e=>document.getElementById('itersVal').textContent=e.target.value);
      document.getElementById('len').addEventListener('input', e=>document.getElementById('lenVal').textContent=e.target.value);
      function expand(axiom, rules, iters){
        let s = axiom; for (let i=0;i<iters;i++){ let out=''; for (const ch of s){ out += rules[ch] ?? ch; } s = out; }
        return s;
      }
      function render(){
        const axiom = document.getElementById('axiom').value;
        let rules; try { rules = JSON.parse(document.getElementById('rules').value); } catch(e){ alert('Rules must be JSON mapping like {"F":"F+F"}'); return; }
        const angle = (+document.getElementById('angle').value) * Math.PI/180;
        const iters = +document.getElementById('iters').value;
        const len = +document.getElementById('len').value;
        const seq = expand(axiom, rules, iters);
        // Fit drawing
        lCtx.clearRect(0,0,lCanvas.width,lCanvas.height);
        lCtx.fillStyle = '#0a0a0a'; lCtx.fillRect(0,0,lCanvas.width,lCanvas.height);
        lCtx.strokeStyle = '#66fcf1'; lCtx.lineWidth = 1;
        let x=lCanvas.width*0.1, y=lCanvas.height*0.9, dir=-Math.PI/2; // start bottom-left, facing up
        const stack = [];
        lCtx.beginPath(); lCtx.moveTo(x,y);
        for (const ch of seq){
          if (ch==='F'){ x += Math.cos(dir)*len; y += Math.sin(dir)*len; lCtx.lineTo(x,y); }
          else if (ch==='f'){ x += Math.cos(dir)*len; y += Math.sin(dir)*len; lCtx.moveTo(x,y); }
          else if (ch==='+' ){ dir += angle; }
          else if (ch==='−' || ch==='-'){ dir -= angle; }
          else if (ch==='['){ stack.push([x,y,dir]); }
          else if (ch===']'){ const st=stack.pop(); if(st){ [x,y,dir]=st; lCtx.moveTo(x,y); } }
          // Ignore other symbols (X/Y used in some rules)
        }
        lCtx.stroke();
      }
      document.getElementById('render').addEventListener('click', render);
      document.getElementById('save').addEventListener('click', ()=>{
        lCanvas.toBlob((b)=>{ if(!b) return; const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download='lsys.png'; a.click(); URL.revokeObjectURL(u); }, 'image/png');
      });
      setPreset('koch');
      render();
    </script>
  </body>
  </html>

