<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Rule Explorer — Edge of Chaos</title>
    <style>
      :root{ --bg:#0b0c10; --fg:#c5c6c7; --accent:#66fcf1; --muted:#9ea6ae; }
      html,body{ height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial,sans-serif; }
      header{ padding:12px 16px; border-bottom:1px solid #1f2833; display:flex; align-items:center; gap:12px; }
      header h1{ margin:0; font-size:18px; color:var(--accent); }
      main{ display:grid; grid-template-columns: 340px 1fr 380px; gap:12px; height: calc(100% - 56px); }
      @media (max-width: 1100px){ main{ grid-template-columns: 1fr; grid-template-rows: auto 1fr auto; } }
      .panel{ padding:12px; overflow:auto; }
      .controls{ display:grid; gap:10px; }
      .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
      label{ font-size:12px; color:var(--muted); width: 140px; }
      input, select, button{ background:#111318; color:var(--fg); border:1px solid #2b3440; border-radius:6px; padding:6px 8px; }
      input[type="range"]{ width: 200px; }
      button{ cursor:pointer; }
      button.primary{ background:#13343b; border-color:#1b5864; color:#bdf9f5; }
      .small{ font-size:12px; color:var(--muted); }
      .sectionTitle{ font-weight:600; margin-top:4px; }
      .scatterWrap{ position:relative; background:#0a0a0a; height:100%; display:grid; grid-template-rows: auto 1fr; }
      .scatterToolbar{ display:flex; gap:8px; align-items:center; padding:8px; border-bottom:1px solid #1f2833; }
      .scatter{ display:grid; place-items:center; padding:8px; }
      canvas{ background:#0a0a0a; border:1px solid #222; border-radius:6px; max-width:100%; height:auto; }
      .preview{ display:grid; grid-template-rows: auto auto 1fr auto; gap:8px; }
      .bookmarks{ display:grid; gap:8px; }
      .bookmark{ border:1px solid #2b3440; border-radius:6px; padding:6px 8px; background:#0e1116; }
      .metrics{ font-size:12px; color:#aab3bd; }
      .footer{ font-size:12px; color:#8a8f98; padding-top:8px; border-top:1px dashed #23303b; }
      .muted{ color:#9ea6ae; }
    </style>
  </head>
  <body>
    <header>
      <h1>Rule Explorer</h1>
      <span class="small">Explore Life-like rules on an entropy–activity map; preview, bookmark, and export</span>
    </header>
    <main>
      <section class="panel">
        <div class="controls">
          <div class="sectionTitle">Batch Evaluation</div>
          <div class="row">
            <label for="batchSize">Rules to sample</label>
            <input type="range" id="batchSize" min="10" max="500" value="120" />
            <span id="batchSizeVal" class="small">120</span>
          </div>
          <div class="row">
            <label for="steps">Steps per rule</label>
            <input type="range" id="steps" min="20" max="400" value="120" />
            <span id="stepsVal" class="small">120</span>
          </div>
          <div class="row">
            <label for="grid">Grid (cols x rows)</label>
            <select id="grid">
              <option value="96x64">96 x 64</option>
              <option value="128x72">128 x 72</option>
              <option value="160x90">160 x 90</option>
            </select>
          </div>
          <div class="row">
            <label for="density">Initial density</label>
            <input type="range" id="density" min="5" max="80" value="30" />
            <span id="densityVal" class="small">0.30</span>
          </div>
          <div class="row">
            <button id="evaluate" class="primary">Evaluate Batch</button>
            <button id="clearPoints">Clear</button>
          </div>
          <div class="small">Metrics: entropy (Shannon, 0–1) vs activity (mean cell flips per step, normalized).</div>
          <div class="footer">Tip: Click a point to preview the rule on the right. Bookmark interesting rules and export to JSON.</div>
        </div>
      </section>

      <section class="scatterWrap">
        <div class="scatterToolbar small">
          <div>Entropy vs Activity</div>
          <div class="muted" id="countLabel">0 rules</div>
          <div class="muted" id="hoverLabel"></div>
        </div>
        <div class="scatter">
          <canvas id="scatter" width="800" height="600"></canvas>
        </div>
      </section>

      <section class="panel preview">
        <div class="sectionTitle">Preview</div>
        <div class="row">
          <label for="ruleStr">Rule (B*/S*)</label>
          <input id="ruleStr" value="B3/S23" />
          <button id="applyRule">Apply</button>
          <button id="randomRule">Random</button>
        </div>
        <canvas id="preview" width="360" height="240"></canvas>
        <div class="row">
          <button id="start" class="primary">Start</button>
          <button id="pause">Pause</button>
          <button id="seed">Reseed</button>
          <button id="bookmark">Bookmark</button>
        </div>
        <div class="metrics" id="metricLabel">—</div>
        <div class="sectionTitle">Bookmarks</div>
        <div class="bookmarks" id="bookmarks"></div>
        <div class="row">
          <button id="export">Export JSON</button>
          <input type="file" id="importFile" />
          <button id="importBtn">Import</button>
        </div>
      </section>
    </main>
    <script>
      // ---------- Utility ----------
      const $ = (id) => document.getElementById(id);
      function rng(seed){ let s=seed>>>0; return ()=>{ s = (s*1664525 + 1013904223)>>>0; return s/2**32; } }
      function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

      // ---------- CA core ----------
      function parseRule(s){
        // B3/S23 => {b:[3], s:[2,3]}
        const m = s.toUpperCase().match(/^B([0-8]*)\/S([0-8]*)$/);
        if (!m) throw new Error('Bad rule');
        const b = new Set(m[1].split('').filter(x=>x!=='').map(x=>+x));
        const st = new Set(m[2].split('').filter(x=>x!=='').map(x=>+x));
        return { b, s: st, str: `B${[...b].sort().join('')}/S${[...st].sort().join('')}` };
      }
      function randomRule(rand){
        // sample births/survivals with some bias toward nontrivial
        const b = new Set(); const s = new Set();
        for (let n=0;n<=8;n++) if (rand()<0.25) b.add(n);
        for (let n=0;n<=8;n++) if (rand()<0.5) s.add(n);
        // ensure not degenerate
        if (b.size===0) b.add(3);
        if (s.size===0) s.add(2);
        return { b, s, str: `B${[...b].sort().join('')}/S${[...s].sort().join('')}` };
      }
      function makeGrid(w,h,rand,density){
        const g = new Uint8Array(w*h);
        for (let i=0;i<g.length;i++) g[i] = (rand()<density)?1:0;
        return g;
      }
      function step(grid, w, h, rule, next){
        // toroidal wrap
        let flips=0;
        for (let y=0;y<h;y++){
          for (let x=0;x<w;x++){
            const idx=y*w+x;
            let n=0;
            for (let dy=-1;dy<=1;dy++) for (let dx=-1;dx<=1;dx++) if (dx||dy){
              const xx=(x+dx+w)%w, yy=(y+dy+h)%h; n += grid[yy*w+xx];
            }
            const alive = grid[idx]===1;
            let out = alive ? (rule.s.has(n)?1:0) : (rule.b.has(n)?1:0);
            next[idx]=out; if (out!==grid[idx]) flips++;
          }
        }
        grid.set(next);
        return flips;
      }
      function metricsForRule(rule, opts){
        const { w, h, steps, density, seed } = opts;
        const rand = rng(seed);
        const grid = makeGrid(w,h,rand,density);
        const next = new Uint8Array(w*h);
        // entropy over frames and activity (flips per step)
        let Hsum=0, A=0;
        for (let t=0;t<steps;t++){
          // entropy of current grid
          let ones=0; for (let i=0;i<grid.length;i++) ones+=grid[i];
          const p = ones/(w*h); const q=1-p; const eps=1e-9;
          const H = -(p? p*Math.log2(p):0) - (q? q*Math.log2(q):0);
          Hsum += H; // max is 1 bit for binary
          const flips = step(grid, w, h, rule, next);
          A += flips/(w*h);
        }
        return { entropy: Hsum/steps, activity: A/steps };
      }

      // ---------- Scatter plot ----------
      const scat = $('scatter');
      const sctx = scat.getContext('2d');
      const points = []; // {x,y,rule,metrics}
      function drawAxes(){
        sctx.clearRect(0,0,scat.width,scat.height);
        // axes and grid
        sctx.fillStyle='#101418'; sctx.fillRect(0,0,scat.width,scat.height);
        sctx.strokeStyle='#22303b'; sctx.lineWidth=1; sctx.beginPath();
        for (let i=0;i<=10;i++){
          const x = i/10*scat.width; const y=i/10*scat.height;
          sctx.moveTo(x,0); sctx.lineTo(x,scat.height);
          sctx.moveTo(0,y); sctx.lineTo(scat.width,y);
        }
        sctx.stroke();
        sctx.fillStyle='#9ea6ae'; sctx.fillText('Entropy', 10, 16); sctx.fillText('Activity', scat.width-60, scat.height-10);
      }
      function drawPoints(highlightIdx=-1){
        drawAxes();
        for (let i=0;i<points.length;i++){
          const p=points[i];
          const x = p.x*scat.width; const y = (1-p.y)*scat.height;
          sctx.beginPath(); sctx.arc(x,y, i===highlightIdx?4:3, 0, Math.PI*2);
          sctx.fillStyle = i===highlightIdx? '#ffd166' : '#66fcf1';
          sctx.fill();
        }
        $('countLabel').textContent = `${points.length} rules`;
      }
      drawAxes();

      function screenToPoint(mx,my){
        // return nearest index
        let best=-1, bd=1e9;
        for (let i=0;i<points.length;i++){
          const p=points[i];
          const x = p.x*scat.width; const y=(1-p.y)*scat.height;
          const d=(x-mx)**2+(y-my)**2; if (d<bd){ bd=d; best=i; }
        }
        return best;
      }
      scat.addEventListener('mousemove', (e)=>{
        const rect = scat.getBoundingClientRect();
        const i = screenToPoint(e.clientX-rect.left, e.clientY-rect.top);
        if (i>=0){
          const p=points[i];
          $('hoverLabel').textContent = `${p.rule.str}  H=${p.metrics.entropy.toFixed(2)}  A=${p.metrics.activity.toFixed(2)}`;
          drawPoints(i);
        } else {
          $('hoverLabel').textContent=''; drawPoints();
        }
      });
      scat.addEventListener('click', (e)=>{
        const rect=scat.getBoundingClientRect();
        const i = screenToPoint(e.clientX-rect.left, e.clientY-rect.top);
        if (i>=0){ selectRule(points[i].rule); drawPoints(i); }
      });

      // ---------- Batch evaluation ----------
      $('batchSize').addEventListener('input', e=> $('batchSizeVal').textContent = e.target.value);
      $('steps').addEventListener('input', e=> $('stepsVal').textContent = e.target.value);
      $('density').addEventListener('input', e=> $('densityVal').textContent = (e.target.value/100).toFixed(2));
      $('clearPoints').addEventListener('click', ()=>{ points.length=0; drawPoints(); });
      $('evaluate').addEventListener('click', async ()=>{
        const N = +$('batchSize').value;
        const steps = +$('steps').value;
        const [W,H] = $('grid').value.split('x').map(x=>+x);
        const density = +$('density').value/100;
        const rand = rng(Math.floor(Math.random()*2**31));
        // simple throttle to not lock UI
        for (let i=0;i<N;i++){
          const rule = randomRule(rand);
          const m = metricsForRule(rule, { w:W, h:H, steps, density, seed: Math.floor(rand()*1e9) });
          points.push({ x: clamp(m.entropy,0,1), y: clamp(m.activity,0,1), rule, metrics: m });
          if (i%5===0) await new Promise(r=>setTimeout(r,0));
        }
        drawPoints();
      });

      // ---------- Preview panel ----------
      const prev = $('preview'); const pctx = prev.getContext('2d');
      const pState = { w: 180, h: 120, grid: null, next: null, rule: parseRule('B3/S23'), timer: null, running:false, seed: Math.floor(Math.random()*1e9), density:0.3 };
      function initPreview(){
        const rand = rng(pState.seed);
        pState.grid = makeGrid(pState.w, pState.h, rand, pState.density);
        pState.next = new Uint8Array(pState.w*pState.h);
      }
      function drawPreview(){
        const scaleX = prev.width/pState.w, scaleY = prev.height/pState.h;
        const img = pctx.createImageData(prev.width, prev.height);
        const on = [102,252,241], off=[12,13,16];
        for (let y=0;y<prev.height;y++) for (let x=0;x<prev.width;x++){
          const gx = Math.floor(x/scaleX), gy=Math.floor(y/scaleY);
          const v = pState.grid[gy*pState.w+gx]; const o = (y*prev.width+x)*4; const c=v?on:off; img.data[o]=c[0]; img.data[o+1]=c[1]; img.data[o+2]=c[2]; img.data[o+3]=255; }
        pctx.putImageData(img,0,0);
      }
      function tickPreview(){ step(pState.grid, pState.w, pState.h, pState.rule, pState.next); drawPreview(); }
      function start(){ if (pState.running) return; pState.running=true; const loop=()=>{ if (!pState.running) return; tickPreview(); requestAnimationFrame(loop); }; requestAnimationFrame(loop); }
      function pause(){ pState.running=false; }
      function reseed(){ pState.seed = Math.floor(Math.random()*1e9); initPreview(); drawPreview(); }
      function applyRuleStr(){ try{ const r=parseRule($('ruleStr').value.trim()); pState.rule=r; drawPreview(); } catch(e){ alert('Invalid rule. Use format B*/S* e.g., B3/S23'); } }
      function selectRule(rule){ pState.rule = rule; $('ruleStr').value = rule.str; reseed(); drawPreview(); computeAndShowMetrics(rule); }
      function computeAndShowMetrics(rule){
        const m = metricsForRule(rule, { w: pState.w, h: pState.h, steps: 120, density: pState.density, seed: Math.floor(Math.random()*1e9) });
        $('metricLabel').textContent = `${rule.str}  H=${m.entropy.toFixed(2)}  A=${m.activity.toFixed(2)}`;
      }
      $('applyRule').addEventListener('click', applyRuleStr);
      $('randomRule').addEventListener('click', ()=>{ const r=randomRule(rng(Math.random()*1e9)); $('ruleStr').value=r.str; applyRuleStr(); });
      $('start').addEventListener('click', start);
      $('pause').addEventListener('click', pause);
      $('seed').addEventListener('click', reseed);
      initPreview(); drawPreview();

      // ---------- Bookmarks ----------
      const bookmarks = [];
      function renderBookmarks(){
        const host = $('bookmarks'); host.innerHTML='';
        for (let i=0;i<bookmarks.length;i++){
          const b = bookmarks[i];
          const div = document.createElement('div'); div.className='bookmark';
          const title = document.createElement('div'); title.textContent = `${b.rule.str}`; div.appendChild(title);
          const meta = document.createElement('div'); meta.className='metrics'; meta.textContent = `H=${b.metrics.entropy.toFixed(2)}  A=${b.metrics.activity.toFixed(2)}`; div.appendChild(meta);
          const row = document.createElement('div'); row.className='row';
          const btnSel = document.createElement('button'); btnSel.textContent='Preview'; btnSel.onclick = ()=>selectRule(b.rule);
          const btnDel = document.createElement('button'); btnDel.textContent='Remove'; btnDel.onclick = ()=>{ bookmarks.splice(i,1); renderBookmarks(); };
          row.appendChild(btnSel); row.appendChild(btnDel); div.appendChild(row);
          host.appendChild(div);
        }
      }
      $('bookmark').addEventListener('click', ()=>{
        const rule = pState.rule; const m = metricsForRule(rule, { w:pState.w, h:pState.h, steps: 180, density: pState.density, seed: Math.floor(Math.random()*1e9) });
        bookmarks.push({ rule, metrics: m }); renderBookmarks();
      });
      $('export').addEventListener('click', ()=>{
        const data = bookmarks.map(b=>({ rule: b.rule.str, metrics: b.metrics }));
        const blob = new Blob([JSON.stringify({ bookmarks: data }, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='rule_bookmarks.json'; a.click(); URL.revokeObjectURL(url);
      });
      $('importBtn').addEventListener('click', ()=>{
        const f = $('importFile').files[0]; if (!f) return; const r = new FileReader(); r.onload = ()=>{
          try{ const obj = JSON.parse(r.result); if (!obj.bookmarks) throw new Error('Bad file'); bookmarks.length=0; for (const it of obj.bookmarks){ bookmarks.push({ rule: parseRule(it.rule), metrics: it.metrics }); } renderBookmarks(); }
          catch(e){ alert('Failed to import: '+e.message); }
        }; r.readAsText(f);
      });

    </script>
  </body>
  </html>

