<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Live ASCII Camera Studio</title>
    <style>
      :root {
        --bg: #0b0c10;
        --fg: #c5c6c7;
        --accent: #66fcf1;
      }
      html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif; }
      header { padding: 12px 16px; border-bottom: 1px solid #1f2833; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      header h1 { font-size: 18px; margin: 0; color: var(--accent); }
      main { display: grid; grid-template-columns: 320px 1fr; gap: 12px; height: calc(100% - 58px); }
      @media (max-width: 900px) { main { grid-template-columns: 1fr; grid-template-rows: auto 1fr; } }
      .panel { padding: 12px; overflow: auto; }
      .controls { display: grid; gap: 10px; grid-template-columns: 1fr; }
      .row { display: flex; gap: 8px; align-items: center; }
      label { font-size: 12px; color: #9ea6ae; width: 120px; }
      input[type="range"] { width: 100%; }
      select, input, button { background: #111318; color: var(--fg); border: 1px solid #2b3440; border-radius: 6px; padding: 6px 8px; }
      button { cursor: pointer; }
      button.primary { background: #13343b; border-color: #1b5864; color: #bdf9f5; }
      .preview { position: relative; background: #000; height: 100%; display: grid; place-items: center; }
      canvas#ascii { image-rendering: pixelated; }
      .footer { font-size: 12px; color: #8a8f98; padding-top: 8px; border-top: 1px dashed #23303b; }
      .small { font-size: 12px; color: #9ea6ae; }
      .warning { color: #ffcc66; }
      .hidden { display: none; }
    </style>
  </head>
  <body>
    <header>
      <h1>Live ASCII Camera Studio</h1>
      <span class="small">Webcam to ASCII with presets, trails, and recording</span>
    </header>
    <main>
      <section class="panel">
        <div class="controls">
          <div class="row">
            <label for="camera">Camera</label>
            <select id="camera"></select>
            <button id="refresh">Refresh</button>
          </div>
          <div class="row">
            <label for="preset">Charset preset</label>
            <select id="preset">
              <option value="classic">Classic</option>
              <option value="dense">Dense</option>
              <option value="sparse">Sparse</option>
              <option value="blocks">Blocks</option>
            </select>
          </div>
          <div class="row">
            <label for="cols">Columns</label>
            <input type="range" id="cols" min="40" max="220" value="120" />
            <span id="colsVal" class="small">120</span>
          </div>
          <div class="row">
            <label for="fontSize">Font size</label>
            <input type="range" id="fontSize" min="8" max="24" value="12" />
            <span id="fontSizeVal" class="small">12</span>
          </div>
          <div class="row">
            <label for="contrast">Contrast</label>
            <input type="range" id="contrast" min="0" max="200" value="100" />
            <span id="contrastVal" class="small">1.00</span>
          </div>
          <div class="row">
            <label for="trail">Trail α</label>
            <input type="range" id="trail" min="0" max="95" value="40" />
            <span id="trailVal" class="small">0.40</span>
          </div>
          <div class="row">
            <label>Options</label>
            <div class="row" style="flex-wrap:wrap; gap:12px;">
              <label class="row"><input type="checkbox" id="colorize" /> Colorize</label>
              <label class="row"><input type="checkbox" id="invert" /> Invert</label>
              <label class="row"><input type="checkbox" id="mirror" checked /> Mirror</label>
            </div>
          </div>
          <div class="row">
            <button id="snapshot">Snapshot</button>
            <button id="record" class="primary">Start Recording</button>
          </div>
          <div class="footer small">
            <div>Tip: Use localhost/https for camera access. Recording downloads as WebM; snapshot saves PNG.</div>
            <div id="status" class="small"></div>
            <div id="warn" class="small warning"></div>
          </div>
        </div>
      </section>
      <section class="preview">
        <canvas id="ascii" width="960" height="720"></canvas>
        <video id="video" class="hidden" playsinline muted></video>
        <canvas id="work" class="hidden"></canvas>
      </section>
    </main>
    <script>
      const $ = (id) => document.getElementById(id);
      const video = $('video');
      const ascii = $('ascii');
      const ctx = ascii.getContext('2d');
      const work = $('work');
      const wctx = work.getContext('2d');

      const presetCharsets = {
        classic: " .:-=+*#%@",
        dense: " .'`^,:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$",
        sparse: " .'`^\":;,.-~_+*=%#@",
        blocks: " ▁▂▃▄▅▆▇█",
      };

      const state = {
        deviceId: null,
        cols: 120,
        fontSize: 12,
        contrast: 1.0,
        trail: 0.4,
        colorize: false,
        invert: false,
        mirror: true,
        charset: presetCharsets.classic,
        recorder: null,
        chunks: [],
        running: false,
        prevIntensity: null,
      };

      function setStatus(msg) { $('status').textContent = msg || ''; }
      function setWarn(msg) { $('warn').textContent = msg || ''; }

      async function enumerateCameras() {
        const sel = $('camera');
        sel.innerHTML = '';
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const cams = devices.filter(d => d.kind === 'videoinput');
          if (cams.length === 0) {
            sel.innerHTML = '<option>No camera found</option>';
            setWarn('No camera devices detected.');
            return;
          }
          cams.forEach((d, i) => {
            const opt = document.createElement('option');
            opt.value = d.deviceId;
            opt.textContent = d.label || `Camera ${i+1}`;
            sel.appendChild(opt);
          });
          if (!state.deviceId) state.deviceId = cams[0].deviceId;
          sel.value = state.deviceId;
        } catch (e) { setWarn('Failed to enumerate devices: ' + e.message); }
      }

      async function startCamera() {
        setWarn('');
        setStatus('Starting camera…');
        try {
          const constraints = { video: state.deviceId ? { deviceId: { exact: state.deviceId } } : { width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
          await video.play();
          setStatus('Camera running');
          state.running = true;
        } catch (e) {
          setWarn('getUserMedia error: ' + e.message);
        }
      }

      function resizeCanvases() {
        const cols = state.cols;
        const fontSize = state.fontSize;
        ctx.font = `${fontSize}px monospace`;
        const charW = ctx.measureText('M').width;
        const charH = fontSize * 1.2; // approximate line height

        const rect = ascii.parentElement.getBoundingClientRect();
        // Maintain aspect ratio based on video if available
        const aspect = video.videoWidth && video.videoHeight ? (video.videoWidth / video.videoHeight) : (16/9);
        const targetW = Math.min(rect.width - 12, 1280);
        const targetH = targetW / aspect;
        const rows = Math.floor((targetH / charH));
        const width = Math.floor(cols * charW);
        const height = Math.floor(rows * charH);
        ascii.width = width; ascii.height = height;
        ctx.font = `${fontSize}px monospace`;
        ctx.textBaseline = 'top';

        work.width = cols; work.height = rows;
        // reset trail buffer
        state.prevIntensity = new Float32Array(cols * rows);
      }

      function toIntensity(r, g, b) {
        // Luma BT.709
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
      }

      function drawFrame() {
        if (!state.running || video.readyState < 2) { requestAnimationFrame(drawFrame); return; }

        // Fit video into work canvas
        const W = work.width, H = work.height;
        wctx.save();
        if (state.mirror) {
          wctx.translate(W, 0); wctx.scale(-1, 1);
          wctx.drawImage(video, 0, 0, W, H);
          wctx.setTransform(1,0,0,1,0,0);
        } else {
          wctx.drawImage(video, 0, 0, W, H);
        }
        wctx.restore();

        const img = wctx.getImageData(0, 0, W, H).data;
        const chars = state.charset;
        const N = chars.length - 1;
        const contrast = state.contrast;
        const invert = state.invert;
        const trail = state.trail;

        ctx.clearRect(0, 0, ascii.width, ascii.height);
        ctx.fillStyle = '#c9d1d9';
        ctx.globalCompositeOperation = 'source-over';

        const fontSize = state.fontSize;
        const charW = ctx.measureText('M').width;
        const charH = fontSize * 1.2;

        for (let y = 0; y < H; y++) {
          for (let x = 0; x < W; x++) {
            const i = (y * W + x) * 4;
            const r = img[i], g = img[i+1], b = img[i+2];
            const lum = toIntensity(r, g, b) / 255;
            // contrast
            let val = ((lum - 0.5) * contrast + 0.5);
            if (invert) val = 1 - val;
            val = Math.min(1, Math.max(0, val));
            // blend trails
            const idx1d = y * W + x;
            const prev = state.prevIntensity[idx1d] || 0;
            const blended = trail > 0 ? (prev * trail + val * (1 - trail)) : val;
            state.prevIntensity[idx1d] = blended;

            const ci = Math.round((1 - blended) * N);
            const ch = chars[ci];

            if (state.colorize) {
              ctx.fillStyle = `rgb(${r},${g},${b})`;
            } else {
              ctx.fillStyle = '#c9d1d9';
            }
            ctx.fillText(ch, x * charW, y * charH);
          }
        }

        requestAnimationFrame(drawFrame);
      }

      // Recording
      function toggleRecord() {
        if (state.recorder) {
          state.recorder.stop();
          return;
        }
        const stream = ascii.captureStream();
        if (!('MediaRecorder' in window)) {
          setWarn('MediaRecorder not supported.');
          return;
        }
        try {
          state.chunks = [];
          const mr = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
          mr.ondataavailable = e => { if (e.data && e.data.size) state.chunks.push(e.data); };
          mr.onstop = () => {
            const blob = new Blob(state.chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'ascii_camera.webm'; a.click();
            URL.revokeObjectURL(url);
            $('record').textContent = 'Start Recording';
            state.recorder = null; state.chunks = [];
            setStatus('Recording saved');
          };
          mr.start();
          state.recorder = mr;
          $('record').textContent = 'Stop Recording';
          setStatus('Recording…');
        } catch (e) { setWarn('Recorder error: ' + e.message); }
      }

      function snapshot() {
        ascii.toBlob((blob) => {
          if (!blob) return;
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = 'ascii_snapshot.png'; a.click();
          URL.revokeObjectURL(url);
        }, 'image/png');
      }

      // UI bindings
      $('cols').addEventListener('input', e => { state.cols = +e.target.value; $('colsVal').textContent = state.cols; resizeCanvases(); });
      $('fontSize').addEventListener('input', e => { state.fontSize = +e.target.value; $('fontSizeVal').textContent = state.fontSize; resizeCanvases(); });
      $('contrast').addEventListener('input', e => { state.contrast = (+e.target.value)/100; $('contrastVal').textContent = state.contrast.toFixed(2); });
      $('trail').addEventListener('input', e => { state.trail = (+e.target.value)/100; $('trailVal').textContent = state.trail.toFixed(2); });
      $('preset').addEventListener('change', e => { state.charset = presetCharsets[e.target.value] || presetCharsets.classic; });
      $('colorize').addEventListener('change', e => { state.colorize = e.target.checked; });
      $('invert').addEventListener('change', e => { state.invert = e.target.checked; });
      $('mirror').addEventListener('change', e => { state.mirror = e.target.checked; });
      $('snapshot').addEventListener('click', snapshot);
      $('record').addEventListener('click', toggleRecord);
      $('refresh').addEventListener('click', enumerateCameras);
      $('camera').addEventListener('change', e => { state.deviceId = e.target.value; startCamera(); });

      // Kickoff
      (async function init() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          setWarn('getUserMedia not supported in this browser.');
          return;
        }
        await enumerateCameras();
        await startCamera();
        resizeCanvases();
        requestAnimationFrame(drawFrame);
      })();
    </script>
  </body>
  </html>

